<!doctype html>
<meta charset="utf-8" />
<meta name="color-scheme" content="light" />
<meta name="robots" content="noindex" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="icon" type="image/x-icon" href="./favicon.ico">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
<title>~</title>

<!-- Preload theme script to prevent flash -->
<script>
    // Apply theme immediately before page renders to prevent flash
    (function() {
        try {
            const savedSettings = localStorage.getItem('homeSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                const themeName = settings.theme || 'default';
                const isDarkMode = settings.darkMode || false;
                
                // Apply dark mode class
                document.documentElement.classList.toggle('dark-mode', isDarkMode);
                
                // Store theme data in a data attribute for components to access
                document.documentElement.dataset.theme = themeName;
                document.documentElement.dataset.darkMode = isDarkMode;
                
                // Define basic theme properties - just enough to prevent flash
                const BASIC_THEMES = {
                    default: {
                        light: {
                            background: '#f8f5e6',
                            gradient: 'linear-gradient(135deg, #f8f5e6, #f2edd0)',
                            text: '#222222'
                        },
                        dark: {
                            background: '#1a1a1a',
                            gradient: 'linear-gradient(135deg, #222, #333)',
                            text: '#e0e0e0'
                        }
                    },
                    minimal: {
                        light: {
                            background: '#ffffff',
                            gradient: 'none',
                            text: '#000000'
                        },
                        dark: {
                            background: '#000000',
                            gradient: 'none',
                            text: '#ffffff'
                        }
                    },
                    glass: {
                        light: {
                            background: 'rgba(255, 255, 255, 0.7)',
                            gradient: 'linear-gradient(135deg, #f5f7fa, #c3cfe2)',
                            text: '#334155'
                        },
                        dark: {
                            background: 'rgba(15, 23, 42, 0.7)',
                            gradient: 'linear-gradient(135deg, #0f172a, #1e293b)',
                            text: '#e2e8f0'
                        }
                    },
                    ocean: {
                        light: {
                            background: '#e0f7fa',
                            gradient: 'linear-gradient(135deg, #e0f7fa, #80deea 50%, #4dd0e1)',
                            text: '#006064'
                        },
                        dark: {
                            background: '#002f35',
                            gradient: 'linear-gradient(135deg, #002f35, #00363a 50%, #004d40)',
                            text: '#e0f7fa'
                        }
                    },
                    swiss: {
                        light: {
                            background: '#ffffff',
                            gradient: 'none',
                            text: '#111111'
                        },
                        dark: {
                            background: '#000000',
                            gradient: 'none',
                            text: '#ffffff'
                        }
                    }
                };
                
                // Apply basic colors immediately
                const theme = BASIC_THEMES[themeName] || BASIC_THEMES.default;
                const colors = isDarkMode ? theme.dark : theme.light;
                
                document.documentElement.style.backgroundColor = colors.background;
                document.documentElement.style.color = colors.text;
                
                if (colors.gradient && colors.gradient !== 'none') {
                    document.documentElement.style.backgroundImage = colors.gradient;
                }
            }
        } catch (e) {
            console.error('Error pre-loading theme:', e);
        }
    })();
</script>

<script>
    // Initialize and load saved shortcuts
    document.addEventListener('DOMContentLoaded', function() {
        // Mark body as loading
        document.body.classList.add('loading');
        
        // Load saved commands if they exist
        try {
            const savedCommands = localStorage.getItem('homeCommands');
            if (savedCommands) {
                const commandsArray = JSON.parse(savedCommands);
                // Clear the existing commands and add the saved ones
                if (typeof COMMANDS !== 'undefined') {
                    COMMANDS.clear();
                    for (const [key, value] of commandsArray) {
                        COMMANDS.set(key, value);
                    }
                }
            }
        } catch (e) {
            console.error('Error loading saved commands:', e);
        }
        
        // Apply saved theme with full settings
        try {
            const savedSettings = localStorage.getItem('homeSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                
                // Apply dark mode class (already done in preload, but ensure it's set)
                document.documentElement.classList.toggle('dark-mode', settings.darkMode || false);
                
                // Store theme data in a data attribute for commands component to access
                const themeName = settings.theme || 'default';
                const isDarkMode = settings.darkMode || false;
                document.documentElement.dataset.theme = themeName;
                document.documentElement.dataset.darkMode = isDarkMode;
                
                // Update CONFIG with openLinksInNewTab setting
                CONFIG.openLinksInNewTab = settings.openLinksInNewTab || false;
                
                // Apply complete theme styling
                applyTheme(themeName, isDarkMode);
            }
        } catch (e) {
            console.error('Error loading theme settings:', e);
        }
        
        // Show the body after a short delay to ensure everything is rendered
        setTimeout(() => {
            document.body.classList.remove('loading');
        }, 100);
    });

    // Function to apply theme styling
    function applyTheme(themeName, isDarkMode) {
        // Define themes - must match settings.html themes
        const THEMES = {
            default: {
                light: {
                    background: '#f8f5e6',
                    gradient: 'linear-gradient(135deg, #f8f5e6, #f2edd0)',
                    text: '#222222',
                    textSubtle: '#666666',
                    accent: '#333333',
                    hover: '#444444',
                    boxShadow: '0 1px 4px rgba(0, 0, 0, 0.03)'
                },
                dark: {
                    background: '#1a1a1a',
                    gradient: 'linear-gradient(135deg, #222, #333)',
                    text: '#e0e0e0',
                    textSubtle: '#a0a0a0',
                    accent: '#505050',
                    hover: '#707070',
                    boxShadow: '0 1px 4px rgba(0, 0, 0, 0.2)'
                }
            },
            minimal: {
                light: {
                    background: '#ffffff',
                    gradient: 'none',
                    text: '#000000',
                    textSubtle: '#999999',
                    accent: '#cccccc',
                    hover: '#eeeeee',
                    boxShadow: 'none',
                    borderRadius: '0',
                    borderWidth: '0',
                    fontFamily: '"Courier New", monospace',
                    fontSize: '12px',
                    commandsBackground: 'transparent',
                    commandsBorder: 'none',
                    commandsBoxShadow: 'none',
                    commandMaxWidth: '70rem',
                    keyColor: '#666666'
                },
                dark: {
                    background: '#000000',
                    gradient: 'none',
                    text: '#ffffff',
                    textSubtle: '#777777',
                    accent: '#333333',
                    hover: '#222222',
                    boxShadow: 'none',
                    borderRadius: '0',
                    borderWidth: '0',
                    fontFamily: '"Courier New", monospace',
                    fontSize: '12px',
                    commandsBackground: 'transparent',
                    commandsBorder: 'none',
                    commandsBoxShadow: 'none',
                    commandMaxWidth: '70rem',
                    keyColor: '#999999'
                }
            },
            swiss: {
                light: {
                    background: '#ffffff',
                    gradient: 'none',
                    text: '#111111',
                    textSubtle: '#666666',
                    accent: '#ff3b30',
                    hover: '#ff6651',
                    boxShadow: 'none',
                    borderRadius: '0',
                    borderWidth: '0',
                    fontFamily: '"Helvetica Neue", Arial, sans-serif',
                    fontSize: '13px',
                    fontWeight: '300',
                    commandsBackground: 'transparent',
                    commandsBorder: 'none',
                    commandsBoxShadow: 'none',
                    commandMaxWidth: '80rem',
                    keyColor: '#ff3b30',
                    nameSpacing: '0.05em',
                    gridLayout: 'true',
                    letterSpacing: '0.03em',
                    keyFontSize: '1.1em',
                    keyWeight: '700',
                    nameAfterHeight: '0',
                    nameHoverColor: '#ff3b30'
                },
                dark: {
                    background: '#000000',
                    gradient: 'none',
                    text: '#ffffff',
                    textSubtle: '#999999',
                    accent: '#ff3b30',
                    hover: '#ff6651',
                    boxShadow: 'none',
                    borderRadius: '0',
                    borderWidth: '0',
                    fontFamily: '"Helvetica Neue", Arial, sans-serif',
                    fontSize: '13px',
                    fontWeight: '300',
                    commandsBackground: 'transparent',
                    commandsBorder: 'none',
                    commandsBoxShadow: 'none',
                    commandMaxWidth: '80rem',
                    keyColor: '#ff3b30',
                    nameSpacing: '0.05em',
                    gridLayout: 'true',
                    letterSpacing: '0.03em',
                    keyFontSize: '1.1em',
                    keyWeight: '700',
                    nameAfterHeight: '0',
                    nameHoverColor: '#ff3b30',
                    cornerTextTransform: 'uppercase',
                    cornerTextSpacing: '0.1em',
                    cornerTextWeight: '400',
                    cornerTextSize: '0.65rem'
                }
            },
            glass: {
                light: {
                    background: 'rgba(255, 255, 255, 0.7)',
                    gradient: 'linear-gradient(135deg, #f5f7fa, #c3cfe2)',
                    text: '#334155',
                    textSubtle: '#64748b',
                    accent: '#3b82f6',
                    hover: '#60a5fa',
                    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.05)',
                    borderRadius: '16px',
                    commandsBackground: 'rgba(255, 255, 255, 0.6)',
                    commandsBorder: '1px solid rgba(255, 255, 255, 0.2)',
                    commandsBoxShadow: '0 8px 32px rgba(0, 0, 0, 0.07)',
                    fontFamily: '"Inter", -apple-system, BlinkMacSystemFont, sans-serif',
                    fontSize: '14px',
                    keyColor: '#3b82f6',
                    commandMaxWidth: '60rem',
                    backdropFilter: 'blur(10px)',
                    cornerTextStyle: 'text-transform: uppercase; letter-spacing: 0.1em; font-size: 0.6rem; font-weight: 500;',
                    dotSize: '6px',
                    dotOpacity: '0.7',
                    nameAfterHeight: '2px'
                },
                dark: {
                    background: 'rgba(15, 23, 42, 0.7)',
                    gradient: 'linear-gradient(135deg, #0f172a, #1e293b)',
                    text: '#e2e8f0',
                    textSubtle: '#94a3b8',
                    accent: '#38bdf8',
                    hover: '#7dd3fc',
                    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.2)',
                    borderRadius: '16px',
                    commandsBackground: 'rgba(30, 41, 59, 0.5)',
                    commandsBorder: '1px solid rgba(255, 255, 255, 0.1)',
                    commandsBoxShadow: '0 8px 32px rgba(0, 0, 0, 0.2)',
                    fontFamily: '"Inter", -apple-system, BlinkMacSystemFont, sans-serif',
                    fontSize: '14px',
                    keyColor: '#38bdf8',
                    commandMaxWidth: '60rem',
                    backdropFilter: 'blur(10px)',
                    cornerTextStyle: 'text-transform: uppercase; letter-spacing: 0.1em; font-size: 0.6rem; font-weight: 500;',
                    dotSize: '6px',
                    dotOpacity: '0.7',
                    nameAfterHeight: '2px'
                }
            },
            ocean: {
                light: {
                    background: '#e0f7fa',
                    gradient: 'linear-gradient(135deg, #e0f7fa, #80deea 50%, #4dd0e1)',
                    text: '#006064',
                    textSubtle: '#0097a7',
                    accent: '#00838f',
                    hover: '#006064',
                    boxShadow: '0 4px 14px rgba(0, 131, 143, 0.15)',
                    borderRadius: '12px',
                    commandsBackground: 'rgba(224, 247, 250, 0.8)',
                    commandsBorder: '1px solid rgba(129, 212, 250, 0.4)',
                    commandsBoxShadow: '0 6px 24px rgba(0, 131, 143, 0.1)',
                    fontFamily: '"Inter", -apple-system, BlinkMacSystemFont, sans-serif',
                    fontSize: '14px',
                    keyColor: '#00acc1',
                    commandMaxWidth: '55rem',
                    backdropFilter: 'blur(8px)',
                    cornerTextStyle: 'font-style: italic; letter-spacing: 0.05em; font-size: 0.7rem;',
                    dotSize: '8px',
                    dotOpacity: '0.8',
                    nameAfterHeight: '2px',
                    nameFont: '500',
                    commandsColumns: '3',
                    inputBackground: 'rgba(224, 247, 250, 0.9)',
                    inputBorder: '1px solid rgba(129, 212, 250, 0.5)',
                    inputShadow: '0 2px 10px rgba(0, 131, 143, 0.1)',
                    uiAnimation: 'true',
                    cornerTextOpacity: '0.85'
                },
                dark: {
                    background: '#002f35',
                    gradient: 'linear-gradient(135deg, #002f35, #00363a 50%, #004d40)',
                    text: '#e0f7fa',
                    textSubtle: '#80deea',
                    accent: '#26c6da',
                    hover: '#4dd0e1',
                    boxShadow: '0 4px 14px rgba(0, 172, 193, 0.2)',
                    borderRadius: '12px',
                    commandsBackground: 'rgba(0, 59, 66, 0.7)',
                    commandsBorder: '1px solid rgba(38, 198, 218, 0.2)',
                    commandsBoxShadow: '0 6px 24px rgba(0, 172, 193, 0.15)',
                    fontFamily: '"Inter", -apple-system, BlinkMacSystemFont, sans-serif',
                    fontSize: '14px',
                    keyColor: '#26c6da',
                    commandMaxWidth: '55rem',
                    backdropFilter: 'blur(8px)',
                    cornerTextStyle: 'font-style: italic; letter-spacing: 0.05em; font-size: 0.7rem;',
                    dotSize: '8px',
                    dotOpacity: '0.8',
                    nameAfterHeight: '2px',
                    nameFont: '500',
                    commandsColumns: '3',
                    inputBackground: 'rgba(0, 59, 66, 0.8)',
                    inputBorder: '1px solid rgba(38, 198, 218, 0.3)',
                    inputShadow: '0 2px 10px rgba(0, 172, 193, 0.15)',
                    uiAnimation: 'true',
                    cornerTextOpacity: '0.85'
                }
            }
        };
        
        // Get theme and colors
        const theme = THEMES[themeName] || THEMES.default;
        const colors = isDarkMode ? theme.dark : theme.light;
        
        // Apply basic colors
        document.documentElement.style.setProperty('--color-background', colors.background);
        document.documentElement.style.setProperty('--color-text', colors.text);
        document.documentElement.style.setProperty('--color-text-subtle', colors.textSubtle);
        document.documentElement.style.setProperty('--color-accent', colors.accent);
        document.documentElement.style.setProperty('--color-hover', colors.hover);
        document.documentElement.style.setProperty('--box-shadow', colors.boxShadow);
        
        // Apply gradient
        if (colors.gradient && colors.gradient !== 'none') {
            document.documentElement.style.backgroundImage = colors.gradient;
        } else {
            document.documentElement.style.backgroundImage = 'none';
        }
        
        // Apply additional theme-specific styles
        if (colors.borderRadius) {
            document.documentElement.style.setProperty('--border-radius', colors.borderRadius);
        } else {
            document.documentElement.style.setProperty('--border-radius', '8px');
        }
        
        if (colors.fontFamily) {
            document.documentElement.style.fontFamily = colors.fontFamily;
        } else {
            document.documentElement.style.fontFamily = 'var(--font-family)';
        }
        
        if (colors.fontSize) {
            document.documentElement.style.fontSize = colors.fontSize;
        } else {
            document.documentElement.style.fontSize = 'var(--font-size)';
        }
        
        // Handle special theme properties
        if (themeName === 'minimal') {
            // Set minimal styles for corner texts
            document.querySelectorAll('.corner-text').forEach(el => {
                el.style.opacity = '0';
            });
            
            // Style settings dot for minimal theme
            const settingsDot = document.querySelector('.settings-dot');
            if (settingsDot) {
                settingsDot.style.width = '3px';
                settingsDot.style.height = '3px';
                settingsDot.style.opacity = '0.3';
            }
            
        } else if (themeName === 'glass') {
            // Apply glass theme properties
            document.documentElement.style.backdropFilter = colors.backdropFilter || 'blur(10px)';
            
            // Style corner texts for glass theme
            document.querySelectorAll('.corner-text').forEach(el => {
                el.style.cssText = colors.cornerTextStyle || '';
                el.style.opacity = '0.8';
            });
            
            // Style the settings dot
            const settingsDot = document.querySelector('.settings-dot');
            if (settingsDot) {
                settingsDot.style.width = colors.dotSize || '6px';
                settingsDot.style.height = colors.dotSize || '6px';
                settingsDot.style.opacity = colors.dotOpacity || '0.7';
                settingsDot.style.backgroundColor = colors.accent;
                settingsDot.style.boxShadow = '0 0 10px ' + colors.accent;
            }
            
        } else if (themeName === 'ocean') {
            // Apply Ocean theme properties
            document.documentElement.style.backdropFilter = colors.backdropFilter || 'blur(8px)';
            
            // Style corner texts for Ocean theme
            document.querySelectorAll('.corner-text').forEach(el => {
                el.style.cssText = colors.cornerTextStyle || '';
                el.style.opacity = colors.cornerTextOpacity || '0.85';
            });
            
            // Style the settings dot for Ocean theme
            const settingsDot = document.querySelector('.settings-dot');
            if (settingsDot) {
                settingsDot.style.width = colors.dotSize || '8px';
                settingsDot.style.height = colors.dotSize || '8px';
                settingsDot.style.opacity = colors.dotOpacity || '0.8';
                settingsDot.style.backgroundColor = colors.accent;
                settingsDot.style.boxShadow = '0 0 12px ' + colors.accent;
            }
            
            // Add animations if enabled
            if (colors.uiAnimation === 'true') {
                // Add pulse animation to the dot
                const styleElement = document.getElementById('ocean-animations');
                if (!styleElement) {
                    const style = document.createElement('style');
                    style.id = 'ocean-animations';
                    style.textContent = `
                        @keyframes pulse {
                            0% { transform: translateX(-50%) scale(1); }
                            50% { transform: translateX(-50%) scale(1.2); }
                            100% { transform: translateX(-50%) scale(1); }
                        }
                        .settings-dot:hover {
                            animation: pulse 1.5s infinite ease-in-out;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                const styleElement = document.getElementById('ocean-animations');
                if (styleElement) {
                    styleElement.remove();
                }
            }
            
        } else if (themeName === 'swiss') {
            // Apply Swiss theme properties for typography
            if (colors.letterSpacing) {
                document.documentElement.style.letterSpacing = colors.letterSpacing;
            }
            
            if (colors.fontWeight) {
                document.documentElement.style.fontWeight = colors.fontWeight;
            }
            
            // Style corner texts for Swiss theme
            document.querySelectorAll('.corner-text').forEach(el => {
                el.style.textTransform = colors.cornerTextTransform || 'uppercase';
                el.style.letterSpacing = colors.cornerTextSpacing || '0.1em';
                el.style.fontWeight = colors.cornerTextWeight || '400';
                el.style.fontSize = colors.cornerTextSize || '0.65rem';
                el.style.opacity = '0.8';
            });
            
            // Style the settings dot
            const settingsDot = document.querySelector('.settings-dot');
            if (settingsDot) {
                settingsDot.style.width = '4px';
                settingsDot.style.height = '4px';
                settingsDot.style.opacity = '0.7';
                settingsDot.style.backgroundColor = colors.accent;
                settingsDot.style.boxShadow = 'none';
            }
            
            // Add responsive styles for Swiss theme
            const styleElement = document.getElementById('swiss-style');
            if (!styleElement) {
                const swissStyle = document.createElement('style');
                swissStyle.id = 'swiss-style';
                swissStyle.textContent = `
                    @media (max-width: 768px) {
                        .corner-text {
                            padding: 1rem !important;
                            max-width: 150px !important;
                        }
                        
                        .top-left, .top-right, .bottom-left, .bottom-right {
                            font-size: 0.6rem !important;
                        }
                    }
                    
                    @media (max-width: 480px) {
                        .top-left, .bottom-right {
                            display: none !important;
                        }
                        
                        .top-right, .bottom-left {
                            padding: 0.75rem !important;
                            font-size: 0.55rem !important;
                        }
                    }
                `;
                document.head.appendChild(swissStyle);
            }
            
        } else {
            // Reset to default styles for default theme
            document.documentElement.style.backdropFilter = 'none';
            document.documentElement.style.letterSpacing = '';
            document.documentElement.style.fontWeight = '';
            
            // Remove theme-specific style elements
            const oceanStyles = document.getElementById('ocean-animations');
            if (oceanStyles) oceanStyles.remove();
            
            const swissStyles = document.getElementById('swiss-style');
            if (swissStyles) swissStyles.remove();
            
            // Show corner texts for default theme
            document.querySelectorAll('.corner-text').forEach(el => {
                el.style.cssText = '';
                el.style.opacity = '';
            });
            
            // Reset dot size
            const settingsDot = document.querySelector('.settings-dot');
            if (settingsDot) {
                settingsDot.style.width = '4px';
                settingsDot.style.height = '4px';
                settingsDot.style.opacity = '0.5';
                settingsDot.style.backgroundColor = '';
                settingsDot.style.boxShadow = '';
            }
        }
        
        // Dispatch theme changed event for other components
        document.dispatchEvent(new CustomEvent('themeChanged', {
            detail: { theme: themeName, darkMode: isDarkMode }
        }));
    }

    document.addEventListener('DOMContentLoaded', function() {
        function updateLinks(isLocal) {
            COMMANDS.forEach((value, key) => {
                try {
                    const url = new URL(value.url);
                    if (isLocal && url.hostname === 'ams') {
                        url.hostname = '192.168.1.9';
                    } else if (!isLocal && url.hostname === '192.168.1.9') {
                        url.hostname = 'ams';
                    }
                    value.url = url.toString();
                    console.log(`Updated command ${key}: ${value.url}`);
                } catch (e) {
                    console.error(`Error updating URL for command ${key}:`, e);
                }
            });
            
            // After updating links, manually trigger a re-render of the commands component
            setTimeout(() => {
                const commandsComponent = document.querySelector('commands-component');
                if (commandsComponent) {
                    commandsComponent.initialize();
                }
                // Make sure the page is visible
                document.body.classList.remove('loading');
            }, 10);
        }

        function isLocalNetwork() {
            fetch('https://api.ipify.org?format=json')
                .then(response => response.json())
                .then(data => {
                    const publicIP = data.ip;
                    console.log('Detected public IP:', publicIP);

                    // Resolve a.088899.xyz to get the current public IP
                    fetch('https://dns.google/resolve?name=a.088899.xyz&type=A')
                        .then(response => response.json())
                        .then(dnsData => {
                            const domainIP = dnsData.Answer[0].data;
                            console.log('Resolved domain IP:', domainIP);

                            const isLocal = publicIP === domainIP;
                            console.log('Is local network:', isLocal);

                            updateLinks(isLocal);
                        })
                        .catch(error => {
                            console.error('Error resolving domain IP:', error);
                            // Show the body even if there's an error
                            document.body.classList.remove('loading');
                        });
                })
                .catch(error => {
                    console.error('Error detecting public IP:', error);
                    // Show the body even if there's an error
                    document.body.classList.remove('loading');
                });
        }

        // Start the local network check
        isLocalNetwork();
        
        // Create settings dot that links to settings.html
        const settingsDot = document.createElement('a');
        settingsDot.className = 'settings-dot';
        settingsDot.href = 'settings.html';
        document.body.appendChild(settingsDot);
        
        // Set greeting and quote
        document.getElementById('greeting').textContent = getGreeting();
        document.getElementById('quote').textContent = getRandomQuote();
        
        // Load corner text
        loadCornerText();
        
        // Failsafe: ensure page becomes visible after 2 seconds no matter what
        setTimeout(() => {
            document.body.classList.remove('loading');
        }, 2000);
    });

    class Commands extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            
            // Apply theme styling immediately in constructor before rendering
            // to prevent any flash of unstyled content
            this._preStyleShadowRoot();
            
            // Wait for the document to be fully loaded before initializing
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => this.initialize());
            } else {
                this.initialize();
            }
        }
        
        // Pre-style the shadow root with theme-specific styles before content is added
        _preStyleShadowRoot() {
            try {
                // Get current theme from document
                const themeName = document.documentElement.dataset.theme || 'default';
                const isDarkMode = document.documentElement.dataset.darkMode === 'true';
                
                // Create a style element for basic container styling
                const style = document.createElement('style');
                
                // Get theme-specific properties based on current theme
                let backgroundColor = 'transparent';
                let border = '1px solid rgba(0, 0, 0, 0.02)';
                let boxShadow = 'var(--box-shadow)';
                let maxWidth = '52rem';
                let backdropFilter = 'none';
                
                if (themeName === 'minimal') {
                    backgroundColor = 'transparent';
                    border = 'none';
                    boxShadow = 'none';
                    maxWidth = '70rem';
                } else if (themeName === 'glass') {
                    backgroundColor = isDarkMode ? 'rgba(30, 41, 59, 0.5)' : 'rgba(255, 255, 255, 0.6)';
                    border = isDarkMode ? '1px solid rgba(255, 255, 255, 0.1)' : '1px solid rgba(255, 255, 255, 0.2)';
                    boxShadow = isDarkMode ? '0 8px 32px rgba(0, 0, 0, 0.2)' : '0 8px 32px rgba(0, 0, 0, 0.07)';
                    backdropFilter = 'blur(10px)';
                    maxWidth = '60rem';
                } else if (themeName === 'ocean') {
                    backgroundColor = isDarkMode ? 'rgba(0, 59, 66, 0.7)' : 'rgba(224, 247, 250, 0.8)';
                    border = isDarkMode ? '1px solid rgba(38, 198, 218, 0.2)' : '1px solid rgba(129, 212, 250, 0.4)';
                    boxShadow = isDarkMode ? '0 6px 24px rgba(0, 172, 193, 0.15)' : '0 6px 24px rgba(0, 131, 143, 0.1)';
                    backdropFilter = 'blur(8px)';
                    maxWidth = '55rem';
                } else if (themeName === 'swiss') {
                    backgroundColor = 'transparent';
                    border = 'none';
                    boxShadow = 'none';
                    maxWidth = '80rem';
                }
                
                // Create basic CSS for the commands container
                style.textContent = `
                    .commands {
                        border-radius: var(--border-radius);
                        column-gap: 2.5rem;
                        columns: 1;
                        list-style: none;
                        margin: 0 auto;
                        overflow: hidden;
                        padding: 2rem;
                        width: 100vw;
                        background-color: ${backgroundColor};
                        border: ${border};
                        box-shadow: ${boxShadow};
                        max-width: ${maxWidth};
                        backdrop-filter: ${backdropFilter};
                    }
                    
                    @media (min-width: 500px) {
                        .commands {
                            columns: 2;
                            max-width: ${themeName === 'minimal' ? '30rem' : '30rem'};
                        }
                    }

                    @media (min-width: 900px) {
                        .commands {
                            columns: ${themeName === 'ocean' ? '3' : '4'};
                            max-width: ${maxWidth};
                        }
                    }
                `;
                
                // Add the style to shadow root
                this.shadowRoot.appendChild(style);
            } catch (e) {
                console.error('Error pre-styling commands component:', e);
            }
        }
        
        initialize() {
            const template = document.getElementById('commands-template');
            const clone = template.content.cloneNode(true);
            const commands = clone.querySelector('.commands');
            const commandTemplate = document.getElementById('command-template');
            
            commands.innerHTML = ''; // Clear existing commands
            
            // Use an array to keep the original order consistent
            const commandEntries = Array.from(COMMANDS.entries());
            
            // Store the original order of keys for reference
            if (!window.originalCommandOrder) {
                window.originalCommandOrder = commandEntries.map(([key]) => key);
            }
            
            // Get current theme
            const currentTheme = document.documentElement.dataset.theme || 'default';
            const isDarkMode = document.documentElement.dataset.darkMode === 'true';
            
            // If Swiss theme is active, ensure we preserve the original order
            if (currentTheme === 'swiss' && window.originalCommandOrder) {
                // Sort command entries using the original order
                commandEntries.sort((a, b) => {
                    const indexA = window.originalCommandOrder.indexOf(a[0]);
                    const indexB = window.originalCommandOrder.indexOf(b[0]);
                    return indexA - indexB;
                });
            }
            
            for (const [key, { name, url }] of commandEntries) {
                if (!name || !url) continue;
                const clone = commandTemplate.content.cloneNode(true);
                const command = clone.querySelector('.command');
                
                // Set command properties
                command.href = url;
                command.dataset.key = key; // Store the key as a data attribute
                command.setAttribute('data-key', key); // Set as attribute for older browsers
                
                // Set target for external links
                if (CONFIG.openLinksInNewTab) command.target = '_blank';
                
                // Set text content for key and name
                clone.querySelector('.key').textContent = key;
                clone.querySelector('.name').textContent = name;
                
                // Add to commands list
                commands.append(clone);
            }
            
            // Clear any pre-styles we added before appending the template content
            this.shadowRoot.innerHTML = '';
            this.shadowRoot.append(clone);
            
            // Apply theme-specific styling to commands
            this.applyThemeStyling(currentTheme, isDarkMode);
        }
        
        // Method to apply theme-specific styling to commands
        applyThemeStyling(themeName, isDarkMode) {
            // Get the commands container
            const commandsMenu = this.shadowRoot.querySelector('.commands');
            if (!commandsMenu) return;
            
            // Reset any previously applied styles
            commandsMenu.style.backgroundColor = '';
            commandsMenu.style.border = '';
            commandsMenu.style.boxShadow = '';
            commandsMenu.style.backdropFilter = '';
            commandsMenu.style.maxWidth = '';
            commandsMenu.style.paddingTop = '';
            
            // Get all keys and names for styling
            const keys = this.shadowRoot.querySelectorAll('.key');
            keys.forEach(key => {
                key.style.color = '';
                key.style.opacity = '';
                key.style.fontWeight = '';
                key.style.fontSize = '';
                key.style.width = '';
                key.style.textAlign = '';
            });
            
            const names = this.shadowRoot.querySelectorAll('.name');
            names.forEach(name => {
                name.style.letterSpacing = '';
                name.style.textTransform = '';
                name.style.fontSize = '';
                name.style.opacity = '';
            });
            
            // Remove any theme-specific styles
            const themeStyles = this.shadowRoot.querySelectorAll('.theme-style');
            themeStyles.forEach(style => style.remove());
            
            // Apply theme-specific styles based on current theme
            if (themeName === 'minimal') {
                // Apply minimal theme to commands
                commandsMenu.style.backgroundColor = 'transparent';
                commandsMenu.style.border = 'none';
                commandsMenu.style.boxShadow = 'none';
                commandsMenu.style.maxWidth = '70rem';
                
                // Update key colors with minimal theme styling
                keys.forEach(key => {
                    key.style.color = isDarkMode ? '#999999' : '#666666';
                });
                
            } else if (themeName === 'glass') {
                // Apply glass theme to commands
                commandsMenu.style.backgroundColor = isDarkMode ? 'rgba(30, 41, 59, 0.5)' : 'rgba(255, 255, 255, 0.6)';
                commandsMenu.style.border = isDarkMode ? '1px solid rgba(255, 255, 255, 0.1)' : '1px solid rgba(255, 255, 255, 0.2)';
                commandsMenu.style.boxShadow = isDarkMode ? '0 8px 32px rgba(0, 0, 0, 0.2)' : '0 8px 32px rgba(0, 0, 0, 0.07)';
                commandsMenu.style.backdropFilter = 'blur(10px)';
                commandsMenu.style.maxWidth = '60rem';
                
                // Update key colors and make them more prominent
                keys.forEach(key => {
                    key.style.color = isDarkMode ? '#38bdf8' : '#3b82f6';
                    key.style.opacity = '1';
                    key.style.fontWeight = '600';
                });
                
                // Update name underline style
                names.forEach(name => {
                    name.style.letterSpacing = '0.02em';
                });
                
                // Add style for name underline
                const style = document.createElement('style');
                style.className = 'theme-style';
                style.textContent = `.name::after { height: 2px !important; }`;
                this.shadowRoot.appendChild(style);
                
            } else if (themeName === 'ocean') {
                // Apply Ocean theme to commands
                commandsMenu.style.backgroundColor = isDarkMode ? 'rgba(0, 59, 66, 0.7)' : 'rgba(224, 247, 250, 0.8)';
                commandsMenu.style.border = isDarkMode ? '1px solid rgba(38, 198, 218, 0.2)' : '1px solid rgba(129, 212, 250, 0.4)';
                commandsMenu.style.boxShadow = isDarkMode ? '0 6px 24px rgba(0, 172, 193, 0.15)' : '0 6px 24px rgba(0, 131, 143, 0.1)';
                commandsMenu.style.backdropFilter = 'blur(8px)';
                commandsMenu.style.maxWidth = '55rem';
                
                // Update key colors with Ocean theme styling
                keys.forEach(key => {
                    key.style.color = isDarkMode ? '#26c6da' : '#00acc1';
                    key.style.opacity = '1';
                    key.style.fontWeight = '600';
                });
                
                // Update name styles with Ocean theme styling
                names.forEach(name => {
                    name.style.letterSpacing = '0.03em';
                    name.style.fontWeight = '500';
                });
                
                // Set columns for the commands menu
                const style = document.createElement('style');
                style.className = 'theme-style';
                style.textContent = `
                    @media (min-width: 500px) {
                        .commands {
                            columns: 3 !important;
                        }
                    }
                    
                    .name::after { 
                        height: 2px !important; 
                        background-color: ${isDarkMode ? '#26c6da' : '#00838f'} !important;
                    }
                    
                    .command {
                        transition: transform 0.3s ease, box-shadow 0.3s ease !important;
                    }
                    .command:hover {
                        transform: translateY(-2px) !important;
                        box-shadow: 0 4px 12px ${isDarkMode ? 'rgba(0, 172, 193, 0.15)' : 'rgba(0, 131, 143, 0.15)'} !important;
                    }
                `;
                this.shadowRoot.appendChild(style);
                
            } else if (themeName === 'swiss') {
                // Apply Swiss theme properties - minimal, typography focused, red accent
                commandsMenu.style.backgroundColor = 'transparent';
                commandsMenu.style.border = 'none';
                commandsMenu.style.boxShadow = 'none';
                commandsMenu.style.maxWidth = '80rem';
                commandsMenu.style.paddingTop = '3rem';
                
                // Update key styling with Swiss typography principles
                keys.forEach(key => {
                    key.style.color = '#ff3b30';
                    key.style.opacity = '1';
                    key.style.fontWeight = '700';
                    key.style.fontSize = '1.1em';
                    key.style.width = 'auto';
                    key.style.textAlign = 'left';
                });
                
                // Update name styles with Swiss typography
                names.forEach(name => {
                    name.style.letterSpacing = '0.05em';
                    name.style.textTransform = 'uppercase';
                    name.style.fontSize = '0.8em';
                    name.style.opacity = '0.9';
                });
                
                // Add grid layout for Swiss theme
                const style = document.createElement('style');
                style.className = 'theme-style';
                style.textContent = `
                    .commands {
                        display: grid !important;
                        grid-template-columns: repeat(4, 1fr) !important;
                        grid-template-rows: repeat(3, auto) !important;
                        grid-gap: 1.5rem !important;
                        grid-auto-flow: column !important;
                        columns: unset !important;
                        padding: 1.5rem !important;
                        justify-content: center !important;
                        align-items: start !important;
                        width: auto !important;
                        max-width: 52rem !important;
                        margin: 0 auto !important;
                    }
                    
                    .command {
                        display: flex !important;
                        flex-direction: column !important;
                        align-items: flex-start !important;
                        gap: 0.5rem !important;
                        border-left: 2px solid transparent !important;
                        padding-left: 0.5rem !important;
                        transition: all 0.2s ease !important;
                        margin-bottom: 0.5rem !important;
                    }
                    
                    .command:hover {
                        border-left-color: #ff3b30 !important;
                    }
                    
                    .command:hover .name {
                        color: #ff3b30 !important;
                    }
                    
                    .name::after {
                        display: none !important;
                    }
                    
                    @media (max-width: 768px) {
                        .commands {
                            grid-template-columns: repeat(4, minmax(90px, 1fr)) !important;
                            grid-gap: 1rem !important;
                            padding: 1rem !important;
                            max-width: 42rem !important;
                        }
                        
                        .command {
                            margin-bottom: 0.25rem !important;
                        }
                        
                        .key {
                            font-size: 1em !important;
                        }
                        
                        .name {
                            font-size: 0.75em !important;
                        }
                    }
                    
                    @media (max-width: 480px) {
                        .commands {
                            grid-template-columns: repeat(2, minmax(90px, 1fr)) !important;
                            max-width: 22rem !important;
                            padding: 0.8rem !important;
                        }
                        
                        .key {
                            font-size: 0.9em !important;
                        }
                        
                        .name {
                            font-size: 0.7em !important;
                            letter-spacing: 0.03em !important;
                        }
                    }
                `;
                this.shadowRoot.appendChild(style);
                
            } else {
                // Default theme styling
                //commandsMenu.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
                commandsMenu.style.border = '1px solid rgba(0, 0, 0, 0.02)';
                commandsMenu.style.boxShadow = 'var(--box-shadow)';
            }
        }
    }

    customElements.define('commands-component', Commands);
</script>

<style>
    :root {
        --border-radius: 8px;
        --color-background: #f8f5e6; /* Vanilla/yellowish background */
        --color-text-subtle: #666666; /* Subtle gray text */
        --color-text: #222222; /* Near black text */
        --color-accent: #333333; /* Accent color */
        --color-hover: #444444; /* Hover color */
        --font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        --font-size: clamp(13px, 1vw, 15px); /* Smaller font size */
        --font-weight-bold: 500;
        --font-weight-normal: 400;
        --space: .5rem;
        --transition-speed: 200ms;
        --box-shadow: 0 1px 4px rgba(0, 0, 0, 0.03);
    }
</style>

<script>
    const CONFIG = {
        commandPathDelimiter: '/',
        commandSearchDelimiter: ' ',
        defaultSearchTemplate: 'https://www.google.com/search?q={}',
        openLinksInNewTab: false,
        suggestionLimit: 4,
    };

    const COMMANDS = new Map([
        ['a', { name: 'Plex', url: 'https://app.plex.tv/desktop/' }],
        ['b', { name: 'Sonarr', url: 'https://sonarr.088899.xyz' }],
        ['c', { name: 'Radarr', url: 'https://radarr.088899.xyz' }],
        ['i', { name: 'Transmission', url: 'https://tr.088899.xyz' }],
        ['f', { name: 'Metube', url: 'https://mt.088899.xyz' }],
        ['g', { name: 'Jackett', url: 'https://jkt.088899.xyz' }],
        ['h', { name: 'DNS', url: 'http://ams:8000' }],
        ['d', { name: 'Twitch', url: 'https://twitch.tv' }],
        ['j', { name: 'Twitter', url: 'https://x.com' }],
        ['k', { name: 'Gmail', url: 'https://gmail.com/' }],
        [
            's',
            {
                name: 'YouTube',
                searchTemplate: '/results?search_query={}',
                url: 'https://youtube.com/',
            },
        ],
        [
            'q',
            {
                name: 'Most used',
                searchTemplate: ':{}',
                suggestions: ['web.whatsapp.com', 'anilist.co', 'discord.com/app'],
                url: 'http://localhost:3000',
            },
        ],
    ]);
</script>

<template id="commands-template">
    <style>
        .commands {
            border-radius: var(--border-radius);
            column-gap: 2.5rem;
            columns: 1;
            list-style: none;
            margin: 0 auto;
            max-width: 10rem;
            overflow: hidden;
            padding: 2rem;
            width: 100vw;
            /*background-color: rgba(255, 255, 255, 0.7);*/
            border: 1px solid rgba(0, 0, 0, 0.02);
            box-shadow: var(--box-shadow);
        }

        .command {
            display: flex;
            gap: 0.8rem;
            outline: 0;
            padding: 0.4rem 0.2rem;
            position: relative;
            text-decoration: none;
            border-radius: var(--border-radius);
            margin-bottom: 12px;
            transition: all var(--transition-speed);
        }

        .command:where(:focus, :hover) {
            background-color: transparent;
        }

        .command:where(:focus, :hover) .name::after {
            width: 100%;
        }
        
        /* Style for editable commands when settings panel is open */
        .editable .command {
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease-in-out;
        }
        
        .editable .command::after {
            content: "";
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.7em;
            opacity: 0;
            transition: opacity var(--transition-speed), transform 0.2s ease;
            color: var(--color-accent);
        }
        
        .editable .command:hover::after {
            opacity: 0.8;
            transform: translateY(-50%) scale(1.2);
        }
        
        .editable .command:hover {
            background-color: rgba(0, 0, 0, 0.03);
            transform: translateX(3px);
            padding-right: 20px; /* Make room for the edit icon */
        }
        
        .key {
            color: var(--color-accent);
            display: inline-block;
            text-align: center;
            width: 1.5ch;
            font-weight: var(--font-weight-bold);
            font-size: 0.85em;
            opacity: 0.65;
        }
        
        .editable .key {
            color: var(--color-hover);
            font-weight: 600;
        }

        .name {
            color: var(--color-text-subtle);
            transition: color var(--transition-speed);
            letter-spacing: 0.01em;
            position: relative;
            font-size: 0.95em;
        }

        .name::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 0;
            height: 1px;
            background-color: var(--color-text);
            transition: width var(--transition-speed);
        }

        .command:where(:focus, :hover) .name {
            color: var(--color-text);
        }

        @media (min-width: 500px) {
            .commands {
                columns: 2;
                max-width: 30rem;
            }
        }

        @media (min-width: 900px) {
            .commands {
                columns: 4;
                max-width: 52rem;
            }
        }
    </style>
    <nav>
        <menu class="commands"></menu>
    </nav>
</template>

<template id="command-template">
    <li>
        <a class="command" rel="noopener noreferrer">
            <span class="key"></span>
            <span class="name"></span>
        </a>
    </li>
</template>

<template id="search-template">
    <style>
        input,
        button {
            -moz-appearance: none;
            -webkit-appearance: none;
            background: transparent;
            border: 0;
            display: block;
            outline: 0;
        }

        .dialog {
            align-items: center;
            background: var(--color-background);
            border: none;
            display: none;
            flex-direction: column;
            height: 100%;
            justify-content: center;
            left: 0;
            padding: 0;
            top: 0;
            width: 100%;
            backdrop-filter: blur(3px);
        }

        .dialog[open] {
            display: flex;
        }

        .form {
            width: 100%;
            max-width: 500px;
        }

        .input {
            color: var(--color-text);
            font-size: 1.3rem;
            font-weight: var(--font-weight-normal);
            padding: 0.5rem 1rem;
            text-align: center;
            width: 100%;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            font-family: var(--font-family);
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: var(--border-radius);
        }

        .suggestions {
            align-items: center;
            display: flex;
            flex-direction: column;
            flex-wrap: wrap;
            justify-content: center;
            list-style: none;
            margin: var(--space) 0 0;
            overflow: hidden;
            padding: 0;
        }

        .suggestion {
            color: var(--color-text);
            cursor: pointer;
            font-size: 0.9rem;
            padding: var(--space);
            position: relative;
            transition: color var(--transition-speed);
            white-space: nowrap;
            z-index: 1;
            border-radius: var(--border-radius);
        }

        .suggestion:where(:focus, :hover) {
            color: var(--color-background);
        }

        .suggestion::before {
            background-color: var(--color-accent);
            border-radius: var(--border-radius);
            content: ' ';
            inset: calc(var(--space) / 1.5) calc(var(--space) / 3);
            opacity: 0;
            position: absolute;
            transform: translateY(0.5em);
            transition: all var(--transition-speed);
            z-index: -1;
        }

        .suggestion:where(:focus, :hover)::before {
            opacity: 1;
            transform: translateY(0);
        }

        .match {
            color: var(--color-text-subtle);
            transition: color var(--transition-speed);
        }

        .suggestion:where(:focus, :hover) .match {
            color: var(--color-background);
        }

        @media (min-width: 700px) {
            .suggestions {
                flex-direction: row;
            }
        }
    </style>
    <dialog class="dialog">
        <form autocomplete="off" class="form" method="dialog" spellcheck="false">
            <input class="input" title="search" type="text" />
            <menu class="suggestions"></menu>
        </form>
    </dialog>
</template>

<template id="suggestion-template">
    <li>
        <button class="suggestion" type="button"></button>
    </li>
</template>

<template id="match-template">
    <span class="match"></span>
</template>

<script type="module">
    class Search extends HTMLElement {
        #dialog;
        #form;
        #input;
        #suggestions;

        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            
            // Apply initial theme styling before content is loaded to prevent flashing
            this._preStyleShadowRoot();
            
            const template = document.getElementById('search-template');
            const clone = template.content.cloneNode(true);
            this.#dialog = clone.querySelector('.dialog');
            this.#form = clone.querySelector('.form');
            this.#input = clone.querySelector('.input');
            this.#suggestions = clone.querySelector('.suggestions');
            this.#form.addEventListener('submit', this.#onSubmit, false);
            this.#input.addEventListener('input', this.#onInput);
            this.#suggestions.addEventListener('click', this.#onSuggestionClick);
            document.addEventListener('keydown', this.#onKeydown);
            
            // Apply theme styling to the clone before appending
            this._applyThemeToClone(clone);
            
            this.shadowRoot.append(clone);
            
            // Listen for theme changes
            document.addEventListener('themeChanged', () => {
                this.applyThemeStyling();
            });
        }
        
        // Pre-style the shadow root with theme-specific styles before content is added
        _preStyleShadowRoot() {
            try {
                // Get current theme from document
                const themeName = document.documentElement.dataset.theme || 'default';
                const isDarkMode = document.documentElement.dataset.darkMode === 'true';
                
                // Create a style element for basic styling
                const style = document.createElement('style');
                
                // Set basic styles based on theme
                let dialogBackground = isDarkMode ? '#1a1a1a' : '#f8f5e6';
                let inputBackground = isDarkMode ? 'rgba(30, 30, 30, 0.5)' : 'rgba(255, 255, 255, 0.7)';
                let inputBorder = isDarkMode ? '1px solid rgba(255, 255, 255, 0.1)' : '1px solid rgba(0, 0, 0, 0.08)';
                let inputBorderRadius = '8px';
                let backdropFilter = 'none';
                
                // Adjust based on theme
                if (themeName === 'minimal') {
                    inputBackground = 'transparent';
                    inputBorder = isDarkMode ? '1px solid rgba(255, 255, 255, 0.2)' : '1px solid rgba(0, 0, 0, 0.2)';
                    inputBorderRadius = '0';
                } else if (themeName === 'glass') {
                    dialogBackground = 'transparent';
                    backdropFilter = 'blur(10px)';
                    inputBackground = isDarkMode ? 'rgba(30, 41, 59, 0.5)' : 'rgba(255, 255, 255, 0.6)';
                    inputBorder = isDarkMode ? '1px solid rgba(255, 255, 255, 0.1)' : '1px solid rgba(255, 255, 255, 0.2)';
                    inputBorderRadius = '16px';
                } else if (themeName === 'ocean') {
                    dialogBackground = 'transparent';
                    backdropFilter = 'blur(8px)';
                    inputBackground = isDarkMode ? 'rgba(0, 59, 66, 0.8)' : 'rgba(224, 247, 250, 0.9)';
                    inputBorder = isDarkMode ? '1px solid rgba(38, 198, 218, 0.3)' : '1px solid rgba(129, 212, 250, 0.5)';
                    inputBorderRadius = '12px';
                } else if (themeName === 'swiss') {
                    inputBackground = 'transparent';
                    inputBorder = 'none';
                    inputBorderRadius = '0';
                    inputBorder = isDarkMode ? '1px solid #ff3b30' : '1px solid #ff3b30';
                }
                
                // Create basic CSS for the search elements
                style.textContent = `
                    .dialog {
                        background-color: ${dialogBackground};
                        backdrop-filter: ${backdropFilter};
                    }
                    
                    .input {
                        background-color: ${inputBackground};
                        border: none;
                        border-bottom: ${inputBorder};
                        border-radius: ${inputBorderRadius};
                    }
                `;
                
                // Add the style to shadow root
                this.shadowRoot.appendChild(style);
            } catch (e) {
                console.error('Error pre-styling search component:', e);
            }
        }
        
        // Apply theme styling to the cloned template before appending
        _applyThemeToClone(clone) {
            try {
                const themeName = document.documentElement.dataset.theme || 'default';
                const isDarkMode = document.documentElement.dataset.darkMode === 'true';
                
                const dialog = clone.querySelector('.dialog');
                const input = clone.querySelector('.input');
                
                // Apply theme-specific styling from existing applyThemeStyling method
                if (themeName === 'minimal') {
                    input.style.backgroundColor = 'transparent';
                    input.style.border = 'none';
                    input.style.borderBottom = '1px solid ' + (isDarkMode ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.2)');
                    input.style.borderRadius = '0';
                    input.style.boxShadow = 'none';
                    input.style.fontFamily = '"Courier New", monospace';
                } else if (themeName === 'glass') {
                    dialog.style.backdropFilter = 'blur(10px)';
                    input.style.backdropFilter = 'blur(5px)';
                    input.style.backgroundColor = isDarkMode ? 'rgba(30, 41, 59, 0.5)' : 'rgba(255, 255, 255, 0.6)';
                    input.style.border = isDarkMode ? '1px solid rgba(255, 255, 255, 0.1)' : '1px solid rgba(255, 255, 255, 0.2)';
                    input.style.boxShadow = isDarkMode ? '0 8px 32px rgba(0, 0, 0, 0.2)' : '0 8px 32px rgba(0, 0, 0, 0.07)';
                    input.style.borderRadius = '16px';
                } else if (themeName === 'ocean') {
                    dialog.style.backdropFilter = 'blur(8px)';
                    input.style.backgroundColor = isDarkMode ? 'rgba(0, 59, 66, 0.8)' : 'rgba(224, 247, 250, 0.9)';
                    input.style.border = isDarkMode ? '1px solid rgba(38, 198, 218, 0.3)' : '1px solid rgba(129, 212, 250, 0.5)';
                    input.style.boxShadow = isDarkMode ? '0 2px 10px rgba(0, 172, 193, 0.15)' : '0 2px 10px rgba(0, 131, 143, 0.1)';
                    input.style.borderRadius = '12px';
                } else if (themeName === 'swiss') {
                    dialog.style.backdropFilter = 'none';
                    input.style.backgroundColor = 'transparent';
                    input.style.border = 'none';
                    input.style.borderBottom = '1px solid #ff3b30';
                    input.style.borderRadius = '0';
                    input.style.boxShadow = 'none';
                    input.style.fontFamily = '"Helvetica Neue", Arial, sans-serif';
                    input.style.letterSpacing = '0.03em';
                }
            } catch (e) {
                console.error('Error applying theme styling to clone:', e);
            }
        }
        
        // Method to apply theme styling when themes change
        applyThemeStyling() {
            const themeName = document.documentElement.dataset.theme || 'default';
            const isDarkMode = document.documentElement.dataset.darkMode === 'true';
            
            // Remove any theme-specific styles
            const themeStyles = this.shadowRoot.querySelectorAll('.theme-style');
            themeStyles.forEach(style => style.remove());
            
            // Reset styles
            this.#dialog.style.backdropFilter = '';
            this.#input.style.backdropFilter = '';
            this.#input.style.backgroundColor = '';
            this.#input.style.border = '';
            this.#input.style.boxShadow = '';
            this.#input.style.borderRadius = '';
            
            // Apply theme-specific styles based on current theme
            if (themeName === 'minimal') {
                // Minimal theme style
                this.#input.style.backgroundColor = 'transparent';
                this.#input.style.border = 'none';
                this.#input.style.borderBottom = '1px solid ' + (isDarkMode ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.2)');
                this.#input.style.borderRadius = '0';
                this.#input.style.boxShadow = 'none';
                this.#input.style.fontFamily = '"Courier New", monospace';
                
                // Add minimal style for suggestions
                const style = document.createElement('style');
                style.className = 'theme-style';
                style.textContent = `
                    .suggestion::before {
                        border-radius: 0 !important;
                        background-color: ${isDarkMode ? '#333333' : '#cccccc'} !important;
                    }
                `;
                this.shadowRoot.appendChild(style);
                
            } else if (themeName === 'glass') {
                // Glass theme style
                this.#dialog.style.backdropFilter = 'blur(10px)';
                this.#input.style.backdropFilter = 'blur(5px)';
                this.#input.style.backgroundColor = isDarkMode ? 'rgba(30, 41, 59, 0.5)' : 'rgba(255, 255, 255, 0.6)';
                this.#input.style.border = isDarkMode ? '1px solid rgba(255, 255, 255, 0.1)' : '1px solid rgba(255, 255, 255, 0.2)';
                this.#input.style.boxShadow = isDarkMode ? '0 8px 32px rgba(0, 0, 0, 0.2)' : '0 8px 32px rgba(0, 0, 0, 0.07)';
                this.#input.style.borderRadius = '16px';
                
                // Add glass style for suggestions
                const style = document.createElement('style');
                style.className = 'theme-style';
                style.textContent = `
                    .suggestion::before {
                        background-color: ${isDarkMode ? '#38bdf8' : '#3b82f6'} !important;
                        border-radius: 8px !important;
                    }
                `;
                this.shadowRoot.appendChild(style);
                
            } else if (themeName === 'ocean') {
                // Ocean theme style
                this.#dialog.style.backdropFilter = 'blur(8px)';
                this.#input.style.backgroundColor = isDarkMode ? 'rgba(0, 59, 66, 0.8)' : 'rgba(224, 247, 250, 0.9)';
                this.#input.style.border = isDarkMode ? '1px solid rgba(38, 198, 218, 0.3)' : '1px solid rgba(129, 212, 250, 0.5)';
                this.#input.style.boxShadow = isDarkMode ? '0 2px 10px rgba(0, 172, 193, 0.15)' : '0 2px 10px rgba(0, 131, 143, 0.1)';
                this.#input.style.borderRadius = '12px';
                
                // Add ocean style for suggestions
                const style = document.createElement('style');
                style.className = 'theme-style';
                style.textContent = `
                    .suggestion::before {
                        background-color: ${isDarkMode ? '#26c6da' : '#00838f'} !important;
                        border-radius: 6px !important;
                    }
                    .suggestion {
                        transition: transform 0.3s ease !important;
                    }
                    .suggestion:hover {
                        transform: translateY(-2px) !important;
                    }
                `;
                this.shadowRoot.appendChild(style);
                
            } else if (themeName === 'swiss') {
                // Swiss theme style
                this.#dialog.style.backdropFilter = 'none';
                this.#input.style.backgroundColor = 'transparent';
                this.#input.style.border = 'none';
                this.#input.style.borderBottom = '1px solid #ff3b30';
                this.#input.style.borderRadius = '0';
                this.#input.style.boxShadow = 'none';
                this.#input.style.fontFamily = '"Helvetica Neue", Arial, sans-serif';
                this.#input.style.letterSpacing = '0.03em';
                
                // Add Swiss style for the search
                const style = document.createElement('style');
                style.className = 'theme-style';
                style.textContent = `
                    .input {
                        width: 90% !important;
                        max-width: 400px !important;
                        margin: 0 auto !important;
                    }
                    
                    .suggestion::before {
                        background-color: #ff3b30 !important;
                        border-radius: 0 !important;
                    }
                    
                    @media (max-width: 480px) {
                        .input {
                            font-size: 1rem !important;
                            padding: 0.4rem 0.8rem !important;
                        }
                        
                        .suggestion {
                            font-size: 0.8rem !important;
                            padding: 0.4rem !important;
                        }
                    }
                `;
                this.shadowRoot.appendChild(style);
            }
        }

        static #attachSearchPrefix(array, { key, splitBy }) {
            if (!splitBy) return array;
            return array.map((search) => `${key}${splitBy}${search}`);
        }

        static #escapeRegexCharacters(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        static #fetchDuckDuckGoSuggestions(search) {
            return new Promise((resolve) => {
                window.autocompleteCallback = (res) => {
                    const suggestions = [];

                    for (const item of res) {
                        if (item.phrase === search.toLowerCase()) continue;
                        suggestions.push(item.phrase);
                    }

                    resolve(suggestions);
                };

                const script = document.createElement('script');
                document.querySelector('head').appendChild(script);
                script.src = `https://duckduckgo.com/ac/?callback=autocompleteCallback&q=${search}`;
                script.onload = script.remove;
            });
        }

        static #formatSearchUrl(url, searchPath, search) {
            if (!searchPath) return url;
            const [baseUrl] = Search.#splitUrl(url);
            const urlQuery = encodeURIComponent(search);
            searchPath = searchPath.replace(/{}/g, urlQuery);
            return baseUrl + searchPath;
        }

        static #hasProtocol(s) {
            return /^[a-zA-Z]+:\/\//i.test(s);
        }

        static #isUrl(s) {
            return /^((https?:\/\/)?[\w-]+(\.[\w-]+)+\.?(:\d+)?(\/\S*)?)$/i.test(s);
        }

        static #parseQuery = (raw) => {
            const query = raw.trim();

            if (this.#isUrl(query)) {
                const url = this.#hasProtocol(query) ? query : `https://${query}`;
                return { query, url };
            }

            if (COMMANDS.has(query)) {
                const { command, key, url } = COMMANDS.get(query);
                return command ? Search.#parseQuery(command) : { key, query, url };
            }

            let splitBy = CONFIG.commandSearchDelimiter;
            const [searchKey, rawSearch] = query.split(new RegExp(`${splitBy}(.*)`));

            if (COMMANDS.has(searchKey)) {
                const { searchTemplate, url: base } = COMMANDS.get(searchKey);
                const search = rawSearch.trim();
                const url = Search.#formatSearchUrl(base, searchTemplate, search);
                return { key: searchKey, query, search, splitBy, url };
            }

            splitBy = CONFIG.commandPathDelimiter;
            const [pathKey, path] = query.split(new RegExp(`${splitBy}(.*)`));

            if (COMMANDS.has(pathKey)) {
                const { url: base } = COMMANDS.get(pathKey);
                const [baseUrl] = Search.#splitUrl(base);
                const url = `${baseUrl}/${path}`;
                return { key: pathKey, path, query, splitBy, url };
            }

            const [baseUrl, rest] = Search.#splitUrl(CONFIG.defaultSearchTemplate);
            const url = Search.#formatSearchUrl(baseUrl, rest, query);
            return { query, search: query, url };
        };

        static #splitUrl(url) {
            const parser = document.createElement('a');
            parser.href = url;
            const baseUrl = `${parser.protocol}//${parser.hostname}`;
            const rest = `${parser.pathname}${parser.search}`;
            return [baseUrl, rest];
        }

        #close() {
            this.#input.value = '';
            this.#input.blur();
            this.#dialog.close();
            this.#suggestions.innerHTML = '';
        }

        #execute(query) {
            const { url } = Search.#parseQuery(query);
            const target = CONFIG.openLinksInNewTab ? '_blank' : '_self';
            window.open(url, target, 'noopener noreferrer');
            this.#close();
        }

        #focusNextSuggestion(previous = false) {
            const active = this.shadowRoot.activeElement;
            let nextIndex;

            if (active.dataset.index) {
                const activeIndex = Number(active.dataset.index);
                nextIndex = previous ? activeIndex - 1 : activeIndex + 1;
            } else {
                nextIndex = previous ? this.#suggestions.childElementCount - 1 : 0;
            }

            const next = this.#suggestions.children[nextIndex];
            if (next) next.querySelector('.suggestion').focus();
            else this.#input.focus();
        }

        #onInput = async () => {
            const oq = Search.#parseQuery(this.#input.value);

            if (!oq.query) {
                this.#close();
                return;
            }

            let suggestions = COMMANDS.get(oq.query)?.suggestions ?? [];

            if (oq.search && suggestions.length < CONFIG.suggestionLimit) {
                const res = await Search.#fetchDuckDuckGoSuggestions(oq.search);
                const formatted = Search.#attachSearchPrefix(res, oq);
                suggestions = suggestions.concat(formatted);
            }

            const nq = Search.#parseQuery(this.#input.value);
            if (nq.query !== oq.query) return;
            this.#renderSuggestions(suggestions, oq.query);
        };

        #onKeydown = (e) => {
            if (!this.#dialog.open) {
                this.#dialog.show();
                this.#input.focus();

                requestAnimationFrame(() => {
                    // close the search dialog before the next repaint if a character is
                    // not produced (e.g. if you type shift, control, alt etc.)
                    if (!this.#input.value) this.#close();
                });

                return;
            }

            if (e.key === 'Escape') {
                this.#close();
                return;
            }

            const alt = e.altKey ? 'alt-' : '';
            const ctrl = e.ctrlKey ? 'ctrl-' : '';
            const meta = e.metaKey ? 'meta-' : '';
            const shift = e.shiftKey ? 'shift-' : '';
            const modifierPrefixedKey = `${alt}${ctrl}${meta}${shift}${e.key}`;

            if (/^(ArrowDown|Tab|ctrl-n)$/.test(modifierPrefixedKey)) {
                e.preventDefault();
                this.#focusNextSuggestion();
                return;
            }

            if (/^(ArrowUp|ctrl-p|shift-Tab)$/.test(modifierPrefixedKey)) {
                e.preventDefault();
                this.#focusNextSuggestion(true);
            }
        };

        #onSubmit = () => {
            this.#execute(this.#input.value);
        };

        #onSuggestionClick = (e) => {
            const ref = e.target.closest('.suggestion');
            if (!ref) return;
            this.#execute(ref.dataset.suggestion);
        };

        #renderSuggestions(suggestions, query) {
            this.#suggestions.innerHTML = '';
            const sliced = suggestions.slice(0, CONFIG.suggestionLimit);
            const template = document.getElementById('suggestion-template');

            for (const [index, suggestion] of sliced.entries()) {
                const clone = template.content.cloneNode(true);
                const ref = clone.querySelector('.suggestion');
                ref.dataset.index = index;
                ref.dataset.suggestion = suggestion;
                const escapedQuery = Search.#escapeRegexCharacters(query);
                const matched = suggestion.match(new RegExp(escapedQuery, 'i'));

                if (matched) {
                    const template = document.getElementById('match-template');
                    const clone = template.content.cloneNode(true);
                    const matchRef = clone.querySelector('.match');
                    const pre = suggestion.slice(0, matched.index);
                    const post = suggestion.slice(matched.index + matched[0].length);
                    matchRef.innerText = matched[0];
                    matchRef.insertAdjacentHTML('beforebegin', pre);
                    matchRef.insertAdjacentHTML('afterend', post);
                    ref.append(clone);
                } else {
                    ref.innerText = suggestion;
                }

                this.#suggestions.append(clone);
            }
        }
    }

    customElements.define('search-component', Search);
</script>

<style>
    html {
        background-color: var(--color-background);
        background-image: linear-gradient(135deg, #f8f5e6, #f2edd0);
        font-family: var(--font-family);
        font-size: var(--font-size);
        line-height: 1.4;
        height: 100%;
    }

    body {
        margin: 0;
        color: var(--color-text);
        height: 100%;
        visibility: visible; /* Changed from opacity to visibility */
    }

    /* Remove the opacity transition */
    body.loading {
        visibility: hidden; /* Hide during loading */
    }

    main {
        align-items: center;
        box-sizing: border-box;
        display: flex;
        justify-content: center;
        min-height: 100vh;
        overflow: hidden;
        padding: calc(var(--space) * 4) var(--space);
        position: relative;
        width: 100vw;
    }

    /* Hide the background element */
    bgelement {
        display: none;
    }

    /* Corner text styles */
    .corner-text {
        position: fixed;
        padding: 2rem;
        font-size: 0.68rem;
        line-height: 1.6;
        color: var(--color-text-subtle);
        opacity: 0.7;
        letter-spacing: 0.03em;
    }

    .top-left {
        top: 0;
        left: 0;
        text-align: left;
    }

    .top-right {
        top: 0;
        right: 0;
        text-align: right;
    }

    .bottom-left {
        bottom: 0;
        left: 0;
        text-align: left;
        max-width: 300px;
        font-style: italic;
    }

    .bottom-right {
        bottom: 0;
        right: 0;
        text-align: right;
    }

    .corner-text span {
        display: inline-block;
    }

    .corner-text .label {
        font-weight: var(--font-weight-bold);
        opacity: 0.8;
        margin-bottom: 0.3rem;
        text-transform: lowercase;
        letter-spacing: 0.05em;
    }
    
    #greeting, #quote, .bottom-right {
        opacity: 0.7;
    }
    
    #quote {
        font-size: 0.65rem;
        max-width: 250px;
        line-height: 1.7;
    }
    
    .bottom-right {
        font-size: 0.65rem;
        letter-spacing: 0.05em;
    }

    /* Settings dot styles */
    .settings-dot {
        position: fixed;
        bottom: 1rem;
        left: 50%;
        transform: translateX(-50%);
        width: 4px; /* Smaller visual dot */
        height: 4px; /* Smaller visual dot */
        background-color: var(--color-text-subtle);
        border-radius: 50%;
        opacity: 0.5;
        cursor: pointer;
        transition: all var(--transition-speed);
        z-index: 10;
        /* Make hit area much larger than visual dot */
        margin: 1.3rem;
        padding: 1px;
        box-sizing: content-box;
        /* Add subtle shadow to make it more visible */
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.1);
        text-decoration: none;
        display: block;
    }

    .settings-dot:hover {
        opacity: 0.8;
        transform: translateX(-50%) scale(1.2);
        background-color: var(--color-accent);
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.15);
    }
    
    /* Responsive styles for various screen sizes */
    @media (max-width: 768px) {
        main {
            padding: calc(var(--space) * 3) var(--space);
            align-items: flex-start;
            padding-top: 4rem;
        }
        
        .corner-text {
            padding: 1.5rem;
        }
    }
    
    @media (max-width: 480px) {
        main {
            padding: calc(var(--space) * 2) var(--space);
            align-items: flex-start;
            padding-top: 3.5rem;
        }
        
        .corner-text {
            padding: 1rem;
        }
        
        .settings-dot {
            bottom: 0.5rem;
        }
    }
</style>

<script>
    // Function to get time of day greeting
    function getGreeting() {
        const hour = new Date().getHours();
        if (hour < 12) return "good morning";
        if (hour < 18) return "good afternoon";
        return "good evening";
    }

    // Random quotes array
    const QUOTES = [
        "The only way to do great work is to love what you do.",
        "Your time is limited, don't waste it living someone else's life.",
        "Stay hungry, stay foolish.",
        "Innovation distinguishes between a leader and a follower.",
        "The greatest glory in living lies not in never falling, but in rising every time we fall.",
        "Education is the most powerful weapon which you can use to change the world.",
        "The only source of knowledge is experience.",
        "Imagination is more important than knowledge.",
        "Strive not to be a success, but rather to be of value.",
        "If you can't explain it simply, you don't understand it well enough."
    ];

    // Function to get random quote
    function getRandomQuote() {
        return QUOTES[Math.floor(Math.random() * QUOTES.length)];
    }

    // Function to load corner text from settings
    function loadCornerText() {
        try {
            const savedSettings = localStorage.getItem('homeSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                const cornerText = document.getElementById('corner-text');
                if (cornerText && settings.cornerText) {
                    cornerText.textContent = settings.cornerText;
                }
            }
        } catch (e) {
            console.error('Error loading corner text:', e);
        }
    }

    // Set corner text content when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('greeting').textContent = getGreeting();
        document.getElementById('quote').textContent = getRandomQuote();
        loadCornerText();
    });

    // Listen for theme changes to update corner text
    document.addEventListener('themeChanged', loadCornerText);
</script>

<style>
    /* New scroll section styles - not modifying any existing styles */
    html {
        scroll-behavior: smooth;
    }
    
    body {
        overflow: hidden; /* Prevent double scrollbars */
    }
    
    .app-container {
        position: relative;
        width: 100%;
        height: 100vh;
        overflow-y: auto;
        overflow-x: hidden;
        scroll-snap-type: y mandatory;
    }
    
    main {
        height: 100vh;
        scroll-snap-align: start;
        position: relative;
    }
    
    .scroll-section {
        min-height: 100vh;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        padding: 5rem 1rem 3rem;
        box-sizing: border-box;
        scroll-snap-align: start;
        background-color: var(--color-background);
        position: relative;
    }
    
    /* Create a pseudo-element to handle the background gradient */
    .scroll-section::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: -1;
        background-image: var(--background-gradient, linear-gradient(135deg, #f8f5e6, #f2edd0));
        opacity: 0.8;
    }
    
    .dark-mode .scroll-section::before {
        background-image: var(--background-gradient, linear-gradient(135deg, #222, #333));
    }
    
    .scroll-content {
        max-width: 90vw;
        width: 100%;
        border-radius: var(--border-radius);
        padding: 2rem;
        box-shadow: var(--box-shadow);
        margin-bottom: 2rem;
        backdrop-filter: blur(5px);
        background-color: rgba(255, 255, 255, 0.7);
    }
    
    .dark-mode .scroll-content {
        background-color: rgba(30, 30, 30, 0.7);
    }
    
    /* RSS Feed Layout Styles */
    .rss-container {
        width: 100%;
        display: grid;
        grid-template-columns: 1fr;
        gap: 2rem;
    }
    
    /* Feed section styling - matches the settings page */
    .feed-section {
        width: 100%;
        border-radius: var(--border-radius);
        overflow: hidden;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        margin-bottom: 2rem;
    }
    
    .dark-mode .feed-section {
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
    }
    
    /* Feed section header styling */
    .feed-section-header {
        display: flex;
        align-items: center;
        margin-bottom: 1.5rem;
    }
    
    .feed-section-title {
        font-size: 1.4rem;
        font-weight: 500;
        margin: 0;
        position: relative;
        padding-left: 1rem;
        color: var(--color-text);
    }
    
    .feed-section-title::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 4px;
        background-color: var(--color-accent);
        border-radius: 2px;
    }
    
    /* Grid for feed cards */
    .feed-cards-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
        gap: 2rem;
        width: 100%;
    }
    
    @media (max-width: 768px) {
        .feed-cards-grid {
            grid-template-columns: 1fr;
        }
    }
    
    /* Feed card styling - matches settings page cards */
    .feed-card {
        background: rgba(255, 255, 255, 0.5);
        border-radius: var(--border-radius);
        padding: 1.5rem;
        box-shadow: var(--box-shadow);
        border: 1px solid rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .feed-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }
    
    .dark-mode .feed-card {
        background: rgba(40, 40, 40, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .dark-mode .feed-card:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    /* Feed card header */
    .feed-card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }
    
    .dark-mode .feed-card-header {
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .feed-card-title {
        margin: 0;
        font-size: 1.2rem;
        font-weight: 500;
    }
    
    .feed-card-source {
        font-size: 0.8rem;
        opacity: 0.7;
        padding: 0.3rem 0.6rem;
        background-color: rgba(0, 0, 0, 0.05);
        border-radius: 20px;
    }
    
    .dark-mode .feed-card-source {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    /* Feed item styling */
    .feed-item {
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }
    
    .dark-mode .feed-item {
        border-bottom: 1px solid rgba(255, 255, 255, 0.03);
    }
    
    .feed-item:last-child {
        margin-bottom: 0;
        padding-bottom: 0;
        border-bottom: none;
    }
    
    .feed-title {
        font-weight: 500;
        margin: 0 0 0.5rem 0;
        font-size: 1.1rem;
    }
    
    .feed-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.8rem;
        margin-bottom: 0.5rem;
        opacity: 0.7;
    }
    
    .feed-source {
        padding: 0.15rem 0.4rem;
        background-color: rgba(0, 0, 0, 0.05);
        border-radius: 4px;
        font-size: 0.75rem;
    }
    
    .dark-mode .feed-source {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    .feed-date {
        font-weight: 500;
        padding: 0.15rem 0.4rem;
        background-color: rgba(0, 0, 0, 0.05);
        border-radius: 4px;
        font-size: 0.75rem;
    }
    
    .dark-mode .feed-date {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    .feed-description {
        margin: 0.5rem 0;
        line-height: 1.5;
    }
    
    .feed-link {
        display: inline-block;
        margin-top: 0.5rem;
        color: var(--color-accent);
        text-decoration: none;
        font-size: 0.9rem;
        transition: all 0.2s ease;
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        background-color: rgba(0, 0, 0, 0.03);
    }
    
    .dark-mode .feed-link {
        background-color: rgba(255, 255, 255, 0.05);
    }
    
    .feed-link:hover {
        color: var(--color-hover);
        text-decoration: underline;
        background-color: rgba(0, 0, 0, 0.05);
    }
    
    .dark-mode .feed-link:hover {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    /* Feed controls */
    .feed-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 2rem;
    }
    
    .feed-title-section {
        display: flex;
        align-items: center;
    }
    
    .feed-title-section h2 {
        margin: 0;
        position: relative;
        padding-left: 1rem;
        color: var(--color-accent);
    }
    
    .feed-title-section h2::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 4px;
        background-color: var(--color-accent);
        border-radius: 2px;
    }
    
    .feed-title-section p {
        margin: 0 0 0 1rem;
        font-size: 0.9rem;
    }
    
    .feed-actions {
        display: flex;
        align-items: center;
        gap: 1rem;
    }
    
    .feed-sort-controls {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .feed-sort-label {
        font-size: 0.8rem;
        color: var(--color-text-subtle);
    }
    
    .feed-sort-select {
        padding: 0.5rem 1rem;
        border-radius: var(--border-radius);
        border: 1px solid rgba(0, 0, 0, 0.1);
        background-color: rgba(255, 255, 255, 0.7);
        font-size: 0.9rem;
        color: var(--color-text);
    }
    
    .dark-mode .feed-sort-select {
        background-color: rgba(0, 0, 0, 0.2);
        border-color: rgba(255, 255, 255, 0.1);
        color: var(--color-text);
    }
    
    .feed-sort-select:focus {
        outline: none;
        border-color: var(--color-accent);
    }
    
    .refresh-button {
        background-color: rgba(0, 0, 0, 0.05);
        border: none;
        border-radius: var(--border-radius);
        color: var(--color-text);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
        padding: 0.5rem 1rem;
        transition: all 0.2s ease;
    }
    
    .dark-mode .refresh-button {
        background-color: rgba(255, 255, 255, 0.1);
    }
    
    .refresh-button:hover {
        background-color: var(--color-accent);
        color: white;
    }
    
    .refresh-icon {
        display: none;
        width: 14px;
        height: 14px;
        margin-right: 6px;
        position: relative;
        transition: transform 0.3s ease;
    }
    
    .refresh-icon::before {
        content: '';
        position: absolute;
        border: 2px solid currentColor;
        border-top-color: transparent;
        border-radius: 50%;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
    }
    
    .refresh-icon::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        width: 0;
        height: 0;
        border-style: solid;
        border-width: 0 4px 4px 0;
        border-color: transparent currentColor transparent transparent;
        transform: rotate(-45deg);
    }
    
    .refresh-button.loading .refresh-icon {
        animation: spin 1s linear infinite;
    }
    
    /* Collapsible section styles */
    .feed-section.collapsible .feed-section-header {
        cursor: pointer;
        position: relative;
    }
    
    .feed-section.collapsible .feed-section-header::after {
        content: '';
        width: 0;
        height: 0;
        border-style: solid;
        border-width: 6px 6px 0 6px;
        border-color: var(--color-text-subtle) transparent transparent transparent;
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        transition: transform 0.2s ease;
    }
    
    .feed-section.collapsible .feed-cards-grid {
        overflow: hidden;
        max-height: 2000px;
        transition: max-height 0.5s ease;
    }
    
    .feed-section.collapsed .feed-cards-grid {
        max-height: 0;
    }
    
    .feed-section.collapsed .feed-section-header::after {
        transform: translateY(-50%) rotate(-90deg);
    }
    
    /* General styles */
    .feed-empty {
        padding: 2rem;
        text-align: center;
        color: var(--color-text-subtle);
        font-style: italic;
    }
    
    .feed-loading {
        text-align: center;
        padding: 2rem;
        color: var(--color-text-subtle);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1rem;
    }
    
    .feed-loading::after {
        content: "";
        width: 2rem;
        height: 2rem;
        border: 2px solid rgba(0, 0, 0, 0.1);
        border-top: 2px solid var(--color-accent);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .dark-mode .feed-loading::after {
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-top: 2px solid var(--color-accent);
    }
</style>

<script>
    // Add scroll section theme handling
    document.addEventListener('DOMContentLoaded', function() {
        // Existing DOMContentLoaded code will run first
        
        // Add scroll section theme handling after a short delay
        setTimeout(() => {
            // Handle theme changes for the scroll section
            function updateScrollSectionTheme() {
                const themeName = document.documentElement.dataset.theme || 'default';
                const isDarkMode = document.documentElement.dataset.darkMode === 'true';
                const scrollContents = document.querySelectorAll('.scroll-content');
                
                // Adjust scroll content appearance based on theme
                scrollContents.forEach(content => {
                    if (themeName === 'glass') {
                        content.style.backdropFilter = 'blur(10px)';
                        content.style.backgroundColor = isDarkMode ? 'rgba(30, 41, 59, 0.5)' : 'rgba(255, 255, 255, 0.6)';
                        content.style.border = isDarkMode ? '1px solid rgba(255, 255, 255, 0.1)' : '1px solid rgba(255, 255, 255, 0.2)';
                    } else if (themeName === 'minimal') {
                        content.style.backdropFilter = 'none';
                        content.style.backgroundColor = 'transparent';
                        content.style.boxShadow = 'none';
                        content.style.border = 'none';
                        content.style.borderBottom = isDarkMode ? '1px solid rgba(255, 255, 255, 0.1)' : '1px solid rgba(0, 0, 0, 0.05)';
                    } else if (themeName === 'ocean') {
                        content.style.backdropFilter = 'blur(8px)';
                        content.style.backgroundColor = isDarkMode ? 'rgba(0, 59, 66, 0.7)' : 'rgba(224, 247, 250, 0.8)';
                        content.style.border = isDarkMode ? '1px solid rgba(38, 198, 218, 0.2)' : '1px solid rgba(129, 212, 250, 0.4)';
                    } else if (themeName === 'swiss') {
                        content.style.backdropFilter = 'none';
                        content.style.backgroundColor = isDarkMode ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.7)';
                        content.style.boxShadow = 'none';
                        content.style.borderLeft = '2px solid ' + (isDarkMode ? '#ff3b30' : '#ff3b30');
                    }
                });
            }
            
            // Apply initial theme
            updateScrollSectionTheme();
            
            // Listen for theme changes
            document.addEventListener('themeChanged', updateScrollSectionTheme);
            
            // Load RSS feeds
            loadRssFeeds();
        }, 100);
    });
    
    // RSS Feed Functionality
    function loadRssFeeds(isRefresh = false) {
        const feedContainer = document.getElementById('rss-feed-container');
        if (!feedContainer) return;
        
        // Show loading state
        if (!isRefresh) {
            feedContainer.innerHTML = '<div class="feed-loading">Loading feeds...</div>';
        } else {
            // If refreshing, just update the refresh button
            const refreshButton = document.getElementById('refresh-button');
            if (refreshButton) {
                refreshButton.classList.add('loading');
                refreshButton.disabled = true;
            }
        }
        
        // Get RSS feed URLs from settings
        let feedUrls = [];
        try {
            const savedSettings = localStorage.getItem('homeSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                feedUrls = settings.rssFeeds || [];
            }
        } catch (e) {
            console.error('Error loading RSS feed settings:', e);
        }
        
        // If no feeds configured, show message
        if (feedUrls.length === 0) {
            feedContainer.innerHTML = `
                <div class="feed-empty">
                    <p>No RSS feeds configured.</p>
                    <p>Add RSS feeds in the <a href="settings.html" style="color: var(--color-accent);">settings page</a>.</p>
                </div>
            `;
            return;
        }
        
        // We'll use a CORS proxy to fetch the RSS feeds
        const corsProxy = 'https://api.allorigins.win/get?url=';
        
        // Use Promise.all to fetch all feeds in parallel
        const feedPromises = feedUrls.map(feedUrl => {
            const encodedUrl = encodeURIComponent(feedUrl);
            return fetch(corsProxy + encodedUrl)
                .then(response => response.json())
                .then(data => {
                    if (data && data.contents) {
                        return parseRSS(data.contents, feedUrl);
                    }
                    throw new Error('Invalid feed data');
                })
                .catch(error => {
                    console.error('Error fetching feed:', feedUrl, error);
                    return {
                        title: 'Error loading feed',
                        link: feedUrl,
                        items: []
                    };
                });
        });
        
        // Handle all feeds
        Promise.all(feedPromises)
            .then(feeds => {
                // If refreshing, keep the existing layout
                if (isRefresh) {
                    const refreshButton = document.getElementById('refresh-button');
                    if (refreshButton) {
                        refreshButton.classList.remove('loading');
                        refreshButton.disabled = false;
                    }
                    // Remove all existing sections except controls
                    const feedItemsContainer = document.getElementById('feed-items-container');
                    if (feedItemsContainer) {
                        feedItemsContainer.innerHTML = '';
                    }
                } else {
                    // Clear loading state
                    feedContainer.innerHTML = '';
                }
                
                // If all feeds failed, show error
                if (feeds.every(feed => feed.items.length === 0)) {
                    if (isRefresh) {
                        const feedItemsContainer = document.getElementById('feed-items-container');
                        if (feedItemsContainer) {
                            feedItemsContainer.innerHTML = `
                                <div class="feed-empty">
                                    <p>Could not load any feeds.</p>
                                    <p>Check the RSS feed URLs in the <a href="settings.html" style="color: var(--color-accent);">settings page</a>.</p>
                                </div>
                            `;
                        }
                    } else {
                        feedContainer.innerHTML = `
                            <div class="feed-empty">
                                <p>Could not load any feeds.</p>
                                <p>Check the RSS feed URLs in the <a href="settings.html" style="color: var(--color-accent);">settings page</a>.</p>
                            </div>
                        `;
                    }
                    return;
                }
                
                // If not refreshing, add the controls
                if (!isRefresh) {
                    // Add feed controls
                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'feed-controls';
                    controlsDiv.innerHTML = `
                        <div class="feed-title-section">
                            <h2>News Feed</h2>
                            <p>Latest updates from your selected sources</p>
                        </div>
                        <div class="feed-actions">
                            <div class="feed-sort-controls">
                                <span class="feed-sort-label">Sort by:</span>
                                <select id="feed-sort" class="feed-sort-select">
                                    <option value="date">Date (Newest first)</option>
                                    <option value="source">Source</option>
                                </select>
                            </div>
                            <button id="refresh-button" class="refresh-button">
                                <span class="refresh-icon"></span>
                                Refresh
                            </button>
                        </div>
                    `;
                    feedContainer.appendChild(controlsDiv);
                    
                    // Create feed container for items
                    const feedItemsContainer = document.createElement('div');
                    feedItemsContainer.id = 'feed-items-container';
                    feedContainer.appendChild(feedItemsContainer);
                    
                    // Add event listener for the refresh button
                    const refreshButton = document.getElementById('refresh-button');
                    refreshButton.addEventListener('click', () => {
                        loadRssFeeds(true); // Pass true to indicate refresh
                    });
                }
                
                // Aggregate all items for date sorting
                let allItems = [];
                feeds.forEach(feed => {
                    if (feed.items.length === 0) return;
                    
                    feed.items.forEach(item => {
                        // Add source info to each item
                        item.sourceName = feed.title;
                        item.sourceUrl = feed.link;
                        allItems.push(item);
                    });
                });
                
                // Sort all items by date (newest first)
                allItems.sort((a, b) => {
                    const dateA = a.pubDate ? new Date(a.pubDate) : new Date(0);
                    const dateB = b.pubDate ? new Date(b.pubDate) : new Date(0);
                    return dateB - dateA; // Newest first
                });
                
                // Function to render feeds by date
                function renderByDate() {
                    const feedItemsContainer = document.getElementById('feed-items-container');
                    if (!feedItemsContainer) return;
                    
                    feedItemsContainer.innerHTML = '';
                    
                    if (allItems.length === 0) {
                        feedItemsContainer.innerHTML = `
                            <div class="feed-empty">No news items found from your feeds.</div>
                        `;
                        return;
                    }
                    
                    // Group items by date (today, yesterday, this week, earlier)
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const yesterday = new Date(today);
                    yesterday.setDate(yesterday.getDate() - 1);
                    const lastWeek = new Date(today);
                    lastWeek.setDate(lastWeek.getDate() - 7);
                    
                    const groupedItems = {
                        today: [],
                        yesterday: [],
                        thisWeek: [],
                        earlier: []
                    };
                    
                    allItems.forEach(item => {
                        const itemDate = item.pubDate ? new Date(item.pubDate) : new Date(0);
                        
                        if (itemDate >= today) {
                            groupedItems.today.push(item);
                        } else if (itemDate >= yesterday) {
                            groupedItems.yesterday.push(item);
                        } else if (itemDate >= lastWeek) {
                            groupedItems.thisWeek.push(item);
                        } else {
                            groupedItems.earlier.push(item);
                        }
                    });
                    
                    // Render each group with a heading
                    const groups = [
                        { name: 'Today', items: groupedItems.today, collapsed: false },
                        { name: 'Yesterday', items: groupedItems.yesterday, collapsed: true },
                        { name: 'This Week', items: groupedItems.thisWeek, collapsed: true },
                        { name: 'Earlier', items: groupedItems.earlier, collapsed: false }
                    ];
                    
                    groups.forEach(group => {
                        if (group.items.length === 0) return;
                        
                        // Create date section
                        const dateSection = document.createElement('div');
                        dateSection.className = `feed-section collapsible ${group.collapsed ? 'collapsed' : ''}`;
                        
                        // Add section header
                        const sectionHeader = document.createElement('div');
                        sectionHeader.className = 'feed-section-header';
                        
                        const sectionTitle = document.createElement('h3');
                        sectionTitle.className = 'feed-section-title';
                        sectionTitle.textContent = group.name;
                        sectionHeader.appendChild(sectionTitle);
                        
                        // Add toggle functionality
                        sectionHeader.addEventListener('click', () => {
                            dateSection.classList.toggle('collapsed');
                        });
                        
                        dateSection.appendChild(sectionHeader);
                        
                        // Create grid for feed cards
                        const cardsGrid = document.createElement('div');
                        cardsGrid.className = 'feed-cards-grid';
                        dateSection.appendChild(cardsGrid);
                        
                        // Group items by source within each date group
                        const sourceMap = new Map();
                        
                        group.items.forEach(item => {
                            if (!sourceMap.has(item.sourceName)) {
                                sourceMap.set(item.sourceName, []);
                            }
                            sourceMap.get(item.sourceName).push(item);
                        });
                        
                        // Create a card for each source
                        sourceMap.forEach((items, sourceName) => {
                            // Create source card
                            const sourceCard = document.createElement('div');
                            sourceCard.className = 'feed-card';
                            
                            // Create card header
                            const cardHeader = document.createElement('div');
                            cardHeader.className = 'feed-card-header';
                            
                            const cardTitle = document.createElement('h4');
                            cardTitle.className = 'feed-card-title';
                            cardTitle.textContent = sourceName;
                            
                            const sourceUrl = items.length > 0 ? items[0].sourceUrl : '#';
                            const cardSource = document.createElement('div');
                            cardSource.className = 'feed-card-source';
                            cardSource.textContent = new URL(sourceUrl).hostname;
                            
                            cardHeader.appendChild(cardTitle);
                            cardHeader.appendChild(cardSource);
                            sourceCard.appendChild(cardHeader);
                            
                            // Add items to the card
                            items.slice(0, 5).forEach(item => {
                                const feedItem = document.createElement('div');
                                feedItem.className = 'feed-item';
                                
                                const itemDate = item.pubDate ? formatDate(new Date(item.pubDate)) : '';
                                
                                feedItem.innerHTML = `
                                    <h3 class="feed-title">${escapeHTML(item.title)}</h3>
                                    <div class="feed-meta">
                                        <span class="feed-date">${itemDate}</span>
                                    </div>
                                    <div class="feed-description">${truncateText(item.description, 150)}</div>
                                    <a href="${item.link}" class="feed-link" target="_blank" rel="noopener noreferrer">Read more</a>
                                `;
                                
                                sourceCard.appendChild(feedItem);
                            });
                            
                            // Add card to grid
                            cardsGrid.appendChild(sourceCard);
                        });
                        
                        feedItemsContainer.appendChild(dateSection);
                    });
                }
                
                // Function to render feeds by source
                function renderBySource() {
                    const feedItemsContainer = document.getElementById('feed-items-container');
                    if (!feedItemsContainer) return;
                    
                    feedItemsContainer.innerHTML = '';
                    
                    if (feeds.every(feed => feed.items.length === 0)) {
                        feedItemsContainer.innerHTML = `
                            <div class="feed-empty">No news items found from your feeds.</div>
                        `;
                        return;
                    }
                    
                    // Create section
                    const sourcesSection = document.createElement('div');
                    sourcesSection.className = 'feed-section';
                    
                    // Add section header
                    const sectionHeader = document.createElement('div');
                    sectionHeader.className = 'feed-section-header';
                    
                    const sectionTitle = document.createElement('h3');
                    sectionTitle.className = 'feed-section-title';
                    sectionTitle.textContent = 'News Sources';
                    sectionHeader.appendChild(sectionTitle);
                    
                    sourcesSection.appendChild(sectionHeader);
                    
                    // Create grid for feed cards
                    const cardsGrid = document.createElement('div');
                    cardsGrid.className = 'feed-cards-grid';
                    sourcesSection.appendChild(cardsGrid);
                    
                    // Display each feed as a card
                    feeds.forEach(feed => {
                        if (feed.items.length === 0) return;
                        
                        // Create source card
                        const sourceCard = document.createElement('div');
                        sourceCard.className = 'feed-card';
                        
                        // Create card header
                        const cardHeader = document.createElement('div');
                        cardHeader.className = 'feed-card-header';
                        
                        const cardTitle = document.createElement('h4');
                        cardTitle.className = 'feed-card-title';
                        cardTitle.textContent = feed.title;
                        
                        const cardSource = document.createElement('div');
                        cardSource.className = 'feed-card-source';
                        cardSource.textContent = new URL(feed.link).hostname;
                        
                        cardHeader.appendChild(cardTitle);
                        cardHeader.appendChild(cardSource);
                        sourceCard.appendChild(cardHeader);
                        
                        // Sort items by date (newest first)
                        feed.items.sort((a, b) => {
                            const dateA = a.pubDate ? new Date(a.pubDate) : new Date(0);
                            const dateB = b.pubDate ? new Date(b.pubDate) : new Date(0);
                            return dateB - dateA; // Newest first
                        });
                        
                        // Add each feed item
                        feed.items.slice(0, 5).forEach(item => {
                            const feedItem = document.createElement('div');
                            feedItem.className = 'feed-item';
                            
                            const itemDate = item.pubDate ? formatDate(new Date(item.pubDate)) : '';
                            
                            feedItem.innerHTML = `
                                <h3 class="feed-title">${escapeHTML(item.title)}</h3>
                                <div class="feed-meta">
                                    <span class="feed-date">${itemDate}</span>
                                </div>
                                <div class="feed-description">${truncateText(item.description, 150)}</div>
                                <a href="${item.link}" class="feed-link" target="_blank" rel="noopener noreferrer">Read more</a>
                            `;
                            
                            sourceCard.appendChild(feedItem);
                        });
                        
                        // Add card to grid
                        cardsGrid.appendChild(sourceCard);
                    });
                    
                    feedItemsContainer.appendChild(sourcesSection);
                }
                
                // Call renderByDate to render the initial view
                renderByDate();
                
                // If we're not refreshing, set up event listeners
                if (!isRefresh) {
                    // Add event listener for sort dropdown
                    const sortSelect = document.getElementById('feed-sort');
                    sortSelect.addEventListener('change', function() {
                        if (this.value === 'date') {
                            renderByDate();
                        } else {
                            renderBySource();
                        }
                    });
                } else {
                    // If refreshing, maintain the current sort option
                    const sortSelect = document.getElementById('feed-sort');
                    if (sortSelect && sortSelect.value === 'source') {
                        renderBySource();
                    } else {
                        renderByDate();
                    }
                }
            })
            .catch(error => {
                console.error('Error processing feeds:', error);
                
                if (isRefresh) {
                    const refreshButton = document.getElementById('refresh-button');
                    if (refreshButton) {
                        refreshButton.classList.remove('loading');
                        refreshButton.disabled = false;
                    }
                    
                    const feedItemsContainer = document.getElementById('feed-items-container');
                    if (feedItemsContainer) {
                        feedItemsContainer.innerHTML = `
                            <div class="feed-error">
                                <p>An error occurred while refreshing feeds.</p>
                                <p>${error.message}</p>
                            </div>
                        `;
                    }
                } else {
                    feedContainer.innerHTML = `
                        <div class="feed-error">
                            <p>An error occurred while loading feeds.</p>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
            });
    }
    
    // Parse RSS content
    function parseRSS(content, feedUrl) {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(content, "text/xml");
        
        // Check if it's a valid feed
        const rssRoot = xmlDoc.querySelector('rss, feed, rdf\\:RDF');
        if (!rssRoot) {
            throw new Error('Invalid RSS/Atom feed format');
        }
        
        // Check feed type and parse accordingly
        let feed = {
            title: 'Unknown Feed',
            link: feedUrl,
            items: []
        };
        
        // RSS 2.0 or 1.0
        const channel = xmlDoc.querySelector('channel');
        if (channel) {
            feed.title = getTextContent(channel, 'title') || feed.title;
            feed.link = getTextContent(channel, 'link') || feed.link;
            
            const items = xmlDoc.querySelectorAll('item');
            feed.items = Array.from(items).map(item => ({
                title: getTextContent(item, 'title') || 'No Title',
                link: getTextContent(item, 'link') || '#',
                description: getTextContent(item, 'description') || '',
                pubDate: getTextContent(item, 'pubDate') || getTextContent(item, 'dc\\:date') || '',
                author: getTextContent(item, 'author') || getTextContent(item, 'dc\\:creator') || ''
            }));
        } 
        // Atom
        else if (xmlDoc.querySelector('feed')) {
            const atomFeed = xmlDoc.querySelector('feed');
            feed.title = getTextContent(atomFeed, 'title') || feed.title;
            
            const linkElem = atomFeed.querySelector('link[rel="alternate"], link[rel="self"]');
            if (linkElem && linkElem.getAttribute('href')) {
                feed.link = linkElem.getAttribute('href');
            }
            
            const entries = xmlDoc.querySelectorAll('entry');
            feed.items = Array.from(entries).map(entry => {
                const entryLink = entry.querySelector('link[rel="alternate"]');
                const link = entryLink ? entryLink.getAttribute('href') : '#';
                
                return {
                    title: getTextContent(entry, 'title') || 'No Title',
                    link: link,
                    description: getTextContent(entry, 'summary') || getTextContent(entry, 'content') || '',
                    pubDate: getTextContent(entry, 'updated') || getTextContent(entry, 'published') || '',
                    author: getTextContent(entry, 'author name') || ''
                };
            });
        }
        
        return feed;
    }
    
    // Helper to get text content from XML element
    function getTextContent(parent, tagName) {
        const elem = parent.querySelector(tagName);
        return elem ? elem.textContent.trim() : '';
    }
    
    // Format date nicely
    function formatDate(date) {
        const now = new Date();
        const diff = now - date;
        
        // Invalid date
        if (isNaN(diff)) return '';
        
        // Less than a minute ago
        if (diff < 60 * 1000) return 'Just now';
        
        // Less than an hour ago
        if (diff < 60 * 60 * 1000) {
            const minutes = Math.floor(diff / (60 * 1000));
            return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        }
        
        // Less than a day ago
        if (diff < 24 * 60 * 60 * 1000) {
            const hours = Math.floor(diff / (60 * 60 * 1000));
            return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        }
        
        // Less than a week ago
        if (diff < 7 * 24 * 60 * 60 * 1000) {
            const days = Math.floor(diff / (24 * 60 * 60 * 1000));
            return `${days} day${days > 1 ? 's' : ''} ago`;
        }
        
        // Regular date format
        const options = { year: 'numeric', month: 'short', day: 'numeric' };
        return date.toLocaleDateString(undefined, options);
    }
    
    // Truncate text with ellipsis
    function truncateText(html, maxLength) {
        // Create a temporary div to parse HTML
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        
        // Get text content
        let text = tempDiv.textContent || tempDiv.innerText || '';
        
        // Truncate if needed
        if (text.length > maxLength) {
            text = text.substring(0, maxLength) + '...';
        }
        
        return escapeHTML(text);
    }
    
    // Escape HTML to prevent XSS
    function escapeHTML(str) {
        if (!str) return '';
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
</script>

<body>
<div class="app-container">
    <main>
        <commands-component></commands-component>
        <search-component></search-component>
    </main>

    <!-- New scrollable section -->
    <section class="scroll-section">
        <div class="scroll-content">
            <div id="rss-feed-container" class="rss-container">
                <div class="feed-loading">Loading feeds...</div>
            </div>
        </div>
    </section>

    <div class="corner-text top-left">
        <span class="label">home</span><br>
        <span class="label">links</span>
    </div>

    <div class="corner-text top-right">
        <span id="greeting">good day</span>
    </div>

    <div class="corner-text bottom-left">
        <span id="quote"></span>
    </div>

    <div class="corner-text bottom-right">
        <span id="corner-text">A. Magno</span>
    </div>
</div>
